"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[455],{5551:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>i,quartoRawHtml:()=>p,toc:()=>c});var a=t(5893),o=t(1151);const r={tags:["group chat","orchestration","RAG"],description:"Implement and manage a multi-agent chat system using AutoGen, where AI assistants retrieve information, generate code, and interact collaboratively to solve complex tasks, especially in areas not covered by their training data.\n",source_notebook:"/notebook/agentchat_groupchat_RAG.ipynb",custom_edit_url:"https://github.com/microsoft/autogen/edit/main/notebook/agentchat_groupchat_RAG.ipynb",title:"Group Chat with Retrieval Augmented Generation"},s="Group Chat with Retrieval Augmented Generation",i={id:"notebooks/agentchat_groupchat_RAG",title:"Group Chat with Retrieval Augmented Generation",description:"Implement and manage a multi-agent chat system using AutoGen, where AI assistants retrieve information, generate code, and interact collaboratively to solve complex tasks, especially in areas not covered by their training data.\n",source:"@site/docs/notebooks/agentchat_groupchat_RAG.mdx",sourceDirName:"notebooks",slug:"/notebooks/agentchat_groupchat_RAG",permalink:"/autogen/docs/notebooks/agentchat_groupchat_RAG",draft:!1,unlisted:!1,editUrl:"https://github.com/microsoft/autogen/edit/main/notebook/agentchat_groupchat_RAG.ipynb",tags:[{label:"group chat",permalink:"/autogen/docs/tags/group-chat"},{label:"orchestration",permalink:"/autogen/docs/tags/orchestration"},{label:"RAG",permalink:"/autogen/docs/tags/rag"}],version:"current",frontMatter:{tags:["group chat","orchestration","RAG"],description:"Implement and manage a multi-agent chat system using AutoGen, where AI assistants retrieve information, generate code, and interact collaboratively to solve complex tasks, especially in areas not covered by their training data.\n",source_notebook:"/notebook/agentchat_groupchat_RAG.ipynb",custom_edit_url:"https://github.com/microsoft/autogen/edit/main/notebook/agentchat_groupchat_RAG.ipynb",title:"Group Chat with Retrieval Augmented Generation"}},l={},c=[{value:"Set your API Endpoint",id:"set-your-api-endpoint",level:2},{value:"Construct Agents",id:"construct-agents",level:2},{value:"Start Chat",id:"start-chat",level:2},{value:"UserProxyAgent doesn\u2019t get the correct code",id:"userproxyagent-doesnt-get-the-correct-code",level:3},{value:"RetrieveUserProxyAgent get the correct code",id:"retrieveuserproxyagent-get-the-correct-code",level:3},{value:"Call RetrieveUserProxyAgent while init chat with another user proxy agent",id:"call-retrieveuserproxyagent-while-init-chat-with-another-user-proxy-agent",level:3}],p=['\x3c!--\ntags: ["group chat", "orchestration", "RAG"]\ndescription: |\n    Implement and manage a multi-agent chat system using AutoGen, where AI assistants retrieve information, generate code, and interact collaboratively to solve complex tasks, especially in areas not covered by their training data.\n--\x3e'];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("div",{dangerouslySetInnerHTML:{__html:p[0]}}),"\n",(0,a.jsx)(n.h1,{id:"group-chat-with-retrieval-augmented-generation",children:"Group Chat with Retrieval Augmented Generation"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://colab.research.google.com/github/microsoft/autogen/blob/main/notebook/agentchat_groupchat_RAG.ipynb",children:(0,a.jsx)(n.img,{src:"https://colab.research.google.com/assets/colab-badge.svg",alt:"Open In Colab"})}),"\n",(0,a.jsx)(n.a,{href:"https://github.com/microsoft/autogen/blob/main/notebook/agentchat_groupchat_RAG.ipynb",children:(0,a.jsx)(n.img,{src:"https://img.shields.io/badge/Open%20on%20GitHub-grey?logo=github",alt:"Open on GitHub"})})]}),"\n",(0,a.jsxs)(n.p,{children:["AutoGen supports conversable agents powered by LLMs, tools, or humans,\nperforming tasks collectively via automated chat. This framework allows\ntool use and human participation through multi-agent conversation.\nPlease find documentation about this feature\n",(0,a.jsx)(n.a,{href:"https://microsoft.github.io/autogen/docs/Use-Cases/agent_chat",children:"here"}),"."]}),"\n",(0,a.jsxs)(n.admonition,{title:"Requirements",type:"info",children:[(0,a.jsx)(n.p,{children:"Some extra dependencies are needed for this notebook, which can be installed via pip:"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"pip install pyautogen[retrievechat]\n"})}),(0,a.jsxs)(n.p,{children:["For more information, please refer to the ",(0,a.jsx)(n.a,{href:"/docs/installation/",children:"installation guide"}),"."]})]}),"\n",(0,a.jsx)(n.h2,{id:"set-your-api-endpoint",children:"Set your API Endpoint"}),"\n",(0,a.jsxs)(n.p,{children:["The\n",(0,a.jsx)(n.a,{href:"https://microsoft.github.io/autogen/docs/reference/oai/openai_utils#config_list_from_json",children:(0,a.jsx)(n.code,{children:"config_list_from_json"})}),"\nfunction loads a list of configurations from an environment variable or\na json file."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import chromadb\n\nimport autogen\nfrom autogen import AssistantAgent\nfrom autogen.agentchat.contrib.retrieve_user_proxy_agent import RetrieveUserProxyAgent\n\nconfig_list = autogen.config_list_from_json("OAI_CONFIG_LIST")\n\nprint("LLM models: ", [config_list[i]["model"] for i in range(len(config_list))])\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"LLM models:  ['gpt-35-turbo', 'gpt-35-turbo-0613']\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["Learn more about configuring LLMs for agents ",(0,a.jsx)(n.a,{href:"/docs/llm_configuration",children:"here"}),"."]})}),"\n",(0,a.jsx)(n.h2,{id:"construct-agents",children:"Construct Agents"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'llm_config = {\n    "timeout": 60,\n    "cache_seed": 42,\n    "config_list": config_list,\n    "temperature": 0,\n}\n\n# autogen.ChatCompletion.start_logging()\n\n\ndef termination_msg(x):\n    return isinstance(x, dict) and "TERMINATE" == str(x.get("content", ""))[-9:].upper()\n\n\nboss = autogen.UserProxyAgent(\n    name="Boss",\n    is_termination_msg=termination_msg,\n    human_input_mode="NEVER",\n    system_message="The boss who ask questions and give tasks.",\n    code_execution_config=False,  # we don\'t want to execute code in this case.\n    default_auto_reply="Reply `TERMINATE` if the task is done.",\n)\n\nboss_aid = RetrieveUserProxyAgent(\n    name="Boss_Assistant",\n    is_termination_msg=termination_msg,\n    system_message="Assistant who has extra content retrieval power for solving difficult problems.",\n    human_input_mode="NEVER",\n    max_consecutive_auto_reply=3,\n    retrieve_config={\n        "task": "code",\n        "docs_path": "https://raw.githubusercontent.com/microsoft/FLAML/main/website/docs/Examples/Integrate%20-%20Spark.md",\n        "chunk_token_size": 1000,\n        "model": config_list[0]["model"],\n        "client": chromadb.PersistentClient(path="/tmp/chromadb"),\n        "collection_name": "groupchat",\n        "get_or_create": True,\n    },\n    code_execution_config=False,  # we don\'t want to execute code in this case.\n)\n\ncoder = AssistantAgent(\n    name="Senior_Python_Engineer",\n    is_termination_msg=termination_msg,\n    system_message="You are a senior python engineer. Reply `TERMINATE` in the end when everything is done.",\n    llm_config=llm_config,\n)\n\npm = autogen.AssistantAgent(\n    name="Product_Manager",\n    is_termination_msg=termination_msg,\n    system_message="You are a product manager. Reply `TERMINATE` in the end when everything is done.",\n    llm_config=llm_config,\n)\n\nreviewer = autogen.AssistantAgent(\n    name="Code_Reviewer",\n    is_termination_msg=termination_msg,\n    system_message="You are a code reviewer. Reply `TERMINATE` in the end when everything is done.",\n    llm_config=llm_config,\n)\n\nPROBLEM = "How to use spark for parallel training in FLAML? Give me sample code."\n\n\ndef _reset_agents():\n    boss.reset()\n    boss_aid.reset()\n    coder.reset()\n    pm.reset()\n    reviewer.reset()\n\n\ndef rag_chat():\n    _reset_agents()\n    groupchat = autogen.GroupChat(\n        agents=[boss_aid, coder, pm, reviewer], messages=[], max_round=12, speaker_selection_method="round_robin"\n    )\n    manager = autogen.GroupChatManager(groupchat=groupchat, llm_config=llm_config)\n\n    # Start chatting with boss_aid as this is the user proxy agent.\n    boss_aid.initiate_chat(\n        manager,\n        problem=PROBLEM,\n        n_results=3,\n    )\n\n\ndef norag_chat():\n    _reset_agents()\n    groupchat = autogen.GroupChat(\n        agents=[boss, coder, pm, reviewer],\n        messages=[],\n        max_round=12,\n        speaker_selection_method="auto",\n        allow_repeat_speaker=False,\n    )\n    manager = autogen.GroupChatManager(groupchat=groupchat, llm_config=llm_config)\n\n    # Start chatting with the boss as this is the user proxy agent.\n    boss.initiate_chat(\n        manager,\n        message=PROBLEM,\n    )\n\n\ndef call_rag_chat():\n    _reset_agents()\n\n    # In this case, we will have multiple user proxy agents and we don\'t initiate the chat\n    # with RAG user proxy agent.\n    # In order to use RAG user proxy agent, we need to wrap RAG agents in a function and call\n    # it from other agents.\n    def retrieve_content(message, n_results=3):\n        boss_aid.n_results = n_results  # Set the number of results to be retrieved.\n        # Check if we need to update the context.\n        update_context_case1, update_context_case2 = boss_aid._check_update_context(message)\n        if (update_context_case1 or update_context_case2) and boss_aid.update_context:\n            boss_aid.problem = message if not hasattr(boss_aid, "problem") else boss_aid.problem\n            _, ret_msg = boss_aid._generate_retrieve_user_reply(message)\n        else:\n            ret_msg = boss_aid.generate_init_message(message, n_results=n_results)\n        return ret_msg if ret_msg else message\n\n    boss_aid.human_input_mode = "NEVER"  # Disable human input for boss_aid since it only retrieves content.\n\n    llm_config = {\n        "functions": [\n            {\n                "name": "retrieve_content",\n                "description": "retrieve content for code generation and question answering.",\n                "parameters": {\n                    "type": "object",\n                    "properties": {\n                        "message": {\n                            "type": "string",\n                            "description": "Refined message which keeps the original meaning and can be used to retrieve content for code generation and question answering.",\n                        }\n                    },\n                    "required": ["message"],\n                },\n            },\n        ],\n        "config_list": config_list,\n        "timeout": 60,\n        "cache_seed": 42,\n    }\n\n    for agent in [coder, pm, reviewer]:\n        # update llm_config for assistant agents.\n        agent.llm_config.update(llm_config)\n\n    for agent in [boss, coder, pm, reviewer]:\n        # register functions for all agents.\n        agent.register_function(\n            function_map={\n                "retrieve_content": retrieve_content,\n            }\n        )\n\n    groupchat = autogen.GroupChat(\n        agents=[boss, coder, pm, reviewer],\n        messages=[],\n        max_round=12,\n        speaker_selection_method="random",\n        allow_repeat_speaker=False,\n    )\n\n    manager_llm_config = llm_config.copy()\n    manager_llm_config.pop("functions")\n    manager = autogen.GroupChatManager(groupchat=groupchat, llm_config=manager_llm_config)\n\n    # Start chatting with the boss as this is the user proxy agent.\n    boss.initiate_chat(\n        manager,\n        message=PROBLEM,\n    )\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"/home/lijiang1/anaconda3/envs/autogen/lib/python3.10/site-packages/tqdm/auto.py:21: TqdmWarning: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html\n  from .autonotebook import tqdm as notebook_tqdm\n/home/lijiang1/anaconda3/envs/autogen/lib/python3.10/site-packages/torch/cuda/__init__.py:138: UserWarning: CUDA initialization: The NVIDIA driver on your system is too old (found version 11060). Please update your GPU driver by downloading and installing a new version from the URL: http://www.nvidia.com/Download/index.aspx Alternatively, go to: https://pytorch.org to install a PyTorch version that has been compiled with your version of the CUDA driver. (Triggered internally at ../c10/cuda/CUDAFunctions.cpp:108.)\n  return torch._C._cuda_getDeviceCount() > 0\n"})}),"\n",(0,a.jsx)(n.h2,{id:"start-chat",children:"Start Chat"}),"\n",(0,a.jsx)(n.h3,{id:"userproxyagent-doesnt-get-the-correct-code",children:"UserProxyAgent doesn\u2019t get the correct code"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/microsoft/FLAML",children:"FLAML"})," was open sourced in 2020, so\nChatGPT is familiar with it. However, Spark-related APIs were added in\n2022, so they were not in ChatGPT\u2019s training data. As a result, we end\nup with invalid code."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"norag_chat()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'Boss (to chat_manager):\n\nHow to use spark for parallel training in FLAML? Give me sample code.\n\n--------------------------------------------------------------------------------\nSenior_Python_Engineer (to chat_manager):\n\nTo use Spark for parallel training in FLAML, you can use the `SparkTrials` class provided by FLAML. Here is a sample code:\n\n```python\nfrom flaml import AutoML\nfrom flaml.data import load_credit\nfrom flaml.model import SparkTrials\n\n# Load data\nX_train, y_train, X_test, y_test = load_credit()\n\n# Define the search space\nsearch_space = {\n    "n_estimators": {"domain": range(10, 100)},\n    "max_depth": {"domain": range(6, 10)},\n    "learning_rate": {"domain": (0.01, 0.1, 1)},\n}\n\n# Create an AutoML instance with SparkTrials\nautoml = AutoML(\n    search_space=search_space,\n    task="classification",\n    n_jobs=1,\n    ensemble_size=0,\n    max_trials=10,\n    trials=SparkTrials(parallelism=2),\n)\n\n# Train the model\nautoml.fit(X_train=X_train, y_train=y_train)\n\n# Evaluate the model\nprint("Best model:", automl.best_model)\nprint("Best hyperparameters:", automl.best_config)\nprint("Test accuracy:", automl.score(X_test=X_test, y_test=y_test))\n\n# Terminate\nTERMINATE\n```\n\nIn this code, we first load the credit dataset. Then, we define the search space for the hyperparameters. We create an `AutoML` instance with `SparkTrials` as the `trials` parameter. We set the `parallelism` parameter to 2, which means that FLAML will use 2 Spark workers to run the trials in parallel. Finally, we fit the model and evaluate it.\n\n--------------------------------------------------------------------------------\nCode_Reviewer (to chat_manager):\n\nGreat! That\'s a clear and concise example. No further questions from my side.\n\n--------------------------------------------------------------------------------\nProduct_Manager (to chat_manager):\n\nThank you! Let me know if you have any other questions.\n\n--------------------------------------------------------------------------------\nBoss (to chat_manager):\n\nReply `TERMINATE` if the task is done.\n\n--------------------------------------------------------------------------------\nSenior_Python_Engineer (to chat_manager):\n\nTERMINATE\n\n--------------------------------------------------------------------------------\nTERMINATE\n\n--------------------------------------------------------------------------------\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"GroupChat select_speaker failed to resolve the next speaker's name. Speaker selection will default to the next speaker in the list. This is because the speaker selection OAI call returned:\nThe next role to play is not specified in the conversation. Please provide more information.\n"})}),"\n",(0,a.jsx)(n.h3,{id:"retrieveuserproxyagent-get-the-correct-code",children:"RetrieveUserProxyAgent get the correct code"}),"\n",(0,a.jsx)(n.p,{children:"Since RetrieveUserProxyAgent can perform retrieval-augmented generation\nbased on the given documentation file, ChatGPT can generate the correct\ncode for us!"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"rag_chat()\n# type exit to terminate the chat\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'Trying to create collection.\ndoc_ids:  [[\'doc_0\', \'doc_1\']]\nAdding doc_id doc_0 to context.\nAdding doc_id doc_1 to context.\nBoss_Assistant (to chat_manager):\n\nYou\'re a retrieve augmented coding assistant. You answer user\'s questions based on your own knowledge and the\ncontext provided by the user.\nIf you can\'t answer the question with or without the current context, you should reply exactly `UPDATE CONTEXT`.\nFor code generation, you must obey the following rules:\nRule 1. You MUST NOT install any packages because all the packages needed are already installed.\nRule 2. You must follow the formats below to write your code:\n```language\n# your code\n```\n\nUser\'s question is: How to use spark for parallel training in FLAML? Give me sample code.\n\nContext is: # Integrate - Spark\n\nFLAML has integrated Spark for distributed training. There are two main aspects of integration with Spark:\n- Use Spark ML estimators for AutoML.\n- Use Spark to run training in parallel spark jobs.\n\n## Spark ML Estimators\n\nFLAML integrates estimators based on Spark ML models. These models are trained in parallel using Spark, so we called them Spark estimators. To use these models, you first need to organize your data in the required format.\n\n### Data\n\nFor Spark estimators, AutoML only consumes Spark data. FLAML provides a convenient function `to_pandas_on_spark` in the `flaml.automl.spark.utils` module to convert your data into a pandas-on-spark (`pyspark.pandas`) dataframe/series, which Spark estimators require.\n\nThis utility function takes data in the form of a `pandas.Dataframe` or `pyspark.sql.Dataframe` and converts it into a pandas-on-spark dataframe. It also takes `pandas.Series` or `pyspark.sql.Dataframe` and converts it into a [pandas-on-spark](https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/index.html) series. If you pass in a `pyspark.pandas.Dataframe`, it will not make any changes.\n\nThis function also accepts optional arguments `index_col` and `default_index_type`.\n- `index_col` is the column name to use as the index, default is None.\n- `default_index_type` is the default index type, default is "distributed-sequence". More info about default index type could be found on Spark official [documentation](https://spark.apache.org/docs/latest/api/python/user_guide/pandas_on_spark/options.html#default-index-type)\n\nHere is an example code snippet for Spark Data:\n\n```python\nimport pandas as pd\nfrom flaml.automl.spark.utils import to_pandas_on_spark\n# Creating a dictionary\ndata = {"Square_Feet": [800, 1200, 1800, 1500, 850],\n      "Age_Years": [20, 15, 10, 7, 25],\n      "Price": [100000, 200000, 300000, 240000, 120000]}\n\n# Creating a pandas DataFrame\ndataframe = pd.DataFrame(data)\nlabel = "Price"\n\n# Convert to pandas-on-spark dataframe\npsdf = to_pandas_on_spark(dataframe)\n```\n\nTo use Spark ML models you need to format your data appropriately. Specifically, use [`VectorAssembler`](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.ml.feature.VectorAssembler.html) to merge all feature columns into a single vector column.\n\nHere is an example of how to use it:\n```python\nfrom pyspark.ml.feature import VectorAssembler\ncolumns = psdf.columns\nfeature_cols = [col for col in columns if col != label]\nfeaturizer = VectorAssembler(inputCols=feature_cols, outputCol="features")\npsdf = featurizer.transform(psdf.to_spark(index_col="index"))["index", "features"]\n```\n\nLater in conducting the experiment, use your pandas-on-spark data like non-spark data and pass them using `X_train, y_train` or `dataframe, label`.\n\n### Estimators\n#### Model List\n- `lgbm_spark`: The class for fine-tuning Spark version LightGBM models, using [SynapseML](https://microsoft.github.io/SynapseML/docs/features/lightgbm/about/) API.\n\n#### Usage\nFirst, prepare your data in the required format as described in the previous section.\n\nBy including the models you intend to try in the `estimators_list` argument to `flaml.automl`, FLAML will start trying configurations for these models. If your input is Spark data, FLAML will also use estimators with the `_spark` postfix by default, even if you haven\'t specified them.\n\nHere is an example code snippet using SparkML models in AutoML:\n\n```python\nimport flaml\n# prepare your data in pandas-on-spark format as we previously mentioned\n\nautoml = flaml.AutoML()\nsettings = {\n    "time_budget": 30,\n    "metric": "r2",\n    "estimator_list": ["lgbm_spark"],  # this setting is optional\n    "task": "regression",\n}\n\nautoml.fit(\n    dataframe=psdf,\n    label=label,\n    **settings,\n)\n```\n\n\n[Link to notebook](https://github.com/microsoft/FLAML/blob/main/notebook/automl_bankrupt_synapseml.ipynb) | [Open in colab](https://colab.research.google.com/github/microsoft/FLAML/blob/main/notebook/automl_bankrupt_synapseml.ipynb)\n\n## Parallel Spark Jobs\nYou can activate Spark as the parallel backend during parallel tuning in both [AutoML](/docs/Use-Cases/Task-Oriented-AutoML#parallel-tuning) and [Hyperparameter Tuning](/docs/Use-Cases/Tune-User-Defined-Function#parallel-tuning), by setting the `use_spark` to `true`. FLAML will dispatch your job to the distributed Spark backend using [`joblib-spark`](https://github.com/joblib/joblib-spark).\n\nPlease note that you should not set `use_spark` to `true` when applying AutoML and Tuning for Spark Data. This is because only SparkML models will be used for Spark Data in AutoML and Tuning. As SparkML models run in parallel, there is no need to distribute them with `use_spark` again.\n\nAll the Spark-related arguments are stated below. These arguments are available in both Hyperparameter Tuning and AutoML:\n\n\n- `use_spark`: boolean, default=False | Whether to use spark to run the training in parallel spark jobs. This can be used to accelerate training on large models and large datasets, but will incur more overhead in time and thus slow down training in some cases. GPU training is not supported yet when use_spark is True. For Spark clusters, by default, we will launch one trial per executor. However, sometimes we want to launch more trials than the number of executors (e.g., local mode). In this case, we can set the environment variable `FLAML_MAX_CONCURRENT` to override the detected `num_executors`. The final number of concurrent trials will be the minimum of `n_concurrent_trials` and `num_executors`.\n- `n_concurrent_trials`: int, default=1 | The number of concurrent trials. When n_concurrent_trials > 1, FLAML performes parallel tuning.\n- `force_cancel`: boolean, default=False | Whether to forcely cancel Spark jobs if the search time exceeded the time budget. Spark jobs include parallel tuning jobs and Spark-based model training jobs.\n\nAn example code snippet for using parallel Spark jobs:\n```python\nimport flaml\nautoml_experiment = flaml.AutoML()\nautoml_settings = {\n    "time_budget": 30,\n    "metric": "r2",\n    "task": "regression",\n    "n_concurrent_trials": 2,\n    "use_spark": True,\n    "force_cancel": True, # Activating the force_cancel option can immediately halt Spark jobs once they exceed the allocated time_budget.\n}\n\nautoml.fit(\n    dataframe=dataframe,\n    label=label,\n    **automl_settings,\n)\n```\n\n\n[Link to notebook](https://github.com/microsoft/FLAML/blob/main/notebook/integrate_spark.ipynb) | [Open in colab](https://colab.research.google.com/github/microsoft/FLAML/blob/main/notebook/integrate_spark.ipynb)\n\n\n\n\n--------------------------------------------------------------------------------\nSenior_Python_Engineer (to chat_manager):\n\nTo use Spark for parallel training in FLAML, you can activate Spark as the parallel backend during parallel tuning in both AutoML and Hyperparameter Tuning, by setting the `use_spark` to `true`. FLAML will dispatch your job to the distributed Spark backend using `joblib-spark`. Here is an example code snippet for using parallel Spark jobs:\n\n```python\nimport flaml\nautoml_experiment = flaml.AutoML()\nautoml_settings = {\n    "time_budget": 30,\n    "metric": "r2",\n    "task": "regression",\n    "n_concurrent_trials": 2,\n    "use_spark": True,\n    "force_cancel": True, # Activating the force_cancel option can immediately halt Spark jobs once they exceed the allocated time_budget.\n}\n\nautoml.fit(\n    dataframe=dataframe,\n    label=label,\n    **automl_settings,\n)\n```\n\nNote that you should not set `use_spark` to `true` when applying AutoML and Tuning for Spark Data. This is because only SparkML models will be used for Spark Data in AutoML and Tuning. As SparkML models run in parallel, there is no need to distribute them with `use_spark` again.\n\nI hope this helps! Let me know if you have any further questions.\n\n--------------------------------------------------------------------------------\nProduct_Manager (to chat_manager):\n\nTERMINATE\n\n--------------------------------------------------------------------------------\n'})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:"Number of requested results 3 is greater than number of elements in index 2, updating n_results = 2\n"})}),"\n",(0,a.jsx)(n.h3,{id:"call-retrieveuserproxyagent-while-init-chat-with-another-user-proxy-agent",children:"Call RetrieveUserProxyAgent while init chat with another user proxy agent"}),"\n",(0,a.jsx)(n.p,{children:"Sometimes, there might be a need to use RetrieveUserProxyAgent in group\nchat without initializing the chat with it. In such scenarios, it\nbecomes essential to create a function that wraps the RAG agents and\nallows them to be called from other agents."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"call_rag_chat()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-text",children:'Boss (to chat_manager):\n\nHow to use spark for parallel training in FLAML? Give me sample code.\n\n--------------------------------------------------------------------------------\nProduct_Manager (to chat_manager):\n\nTo use Spark for parallel training in FLAML, you can follow these steps:\n\n1. Install PySpark and FLAML on your machine.\n2. Start a Spark cluster using the `pyspark` command.\n3. Import the necessary libraries and initialize a SparkSession object.\n4. Load your data into a Spark DataFrame.\n5. Define your search space and search strategy using FLAML\'s API.\n6. Create a SparkEstimator object and pass it to FLAML\'s `fit()` method.\n\nHere\'s some sample code to get you started:\n\n```python\nfrom pyspark.sql import SparkSession\nfrom flaml import AutoML\nfrom flaml.data import get_output_from_log\n\n# Initialize a SparkSession object\nspark = SparkSession.builder.appName("FLAML-Spark").getOrCreate()\n\n# Load your data into a Spark DataFrame\ndata = spark.read.format("csv").option("header", "true").load("path/to/data.csv")\n\n# Define your search space and search strategy\nsearch_space = {\n    "n_estimators": {"domain": range(10, 100)},\n    "max_depth": {"domain": range(1, 10)},\n    "learning_rate": {"domain": [0.001, 0.01, 0.1]},\n}\nsearch_strategy = "skopt"\n\n# Create a SparkEstimator object\nfrom pyspark.ml.classification import GBTClassifier\nestimator = GBTClassifier()\n\n# Pass the SparkEstimator object to FLAML\'s fit() method\nautoml = AutoML()\nautoml.fit(\n    X_train=data,\n    estimator=estimator,\n    task="classification",\n    search_space=search_space,\n    search_alg=search_strategy,\n    n_jobs=-1,\n)\n\n# Get the best model and its hyperparameters\nbest_model = automl.model\nbest_params = automl.best_config\n\n# Print the results\nprint(f"Best model: {best_model}")\nprint(f"Best hyperparameters: {best_params}")\n\n# Stop the SparkSession object\nspark.stop()\n```\n\nNote that the `n_jobs` parameter is set to `-1` to use all available cores on the Spark cluster. You can adjust this value to control the level of parallelism. Also, the `get_output_from_log()` function can be used to extract the results from the FLAML log file. \n\nTERMINATE\n\n--------------------------------------------------------------------------------\nTo use Spark for parallel training in FLAML, you can follow these steps:\n\n1. Install PySpark and FLAML on your machine.\n2. Start a Spark cluster using the `pyspark` command.\n3. Import the necessary libraries and initialize a SparkSession object.\n4. Load your data into a Spark DataFrame.\n5. Define your search space and search strategy using FLAML\'s API.\n6. Create a SparkEstimator object and pass it to FLAML\'s `fit()` method.\n\nHere\'s some sample code to get you started:\n\n```python\nfrom pyspark.sql import SparkSession\nfrom flaml import AutoML\nfrom flaml.data import get_output_from_log\n\n# Initialize a SparkSession object\nspark = SparkSession.builder.appName("FLAML-Spark").getOrCreate()\n\n# Load your data into a Spark DataFrame\ndata = spark.read.format("csv").option("header", "true").load("path/to/data.csv")\n\n# Define your search space and search strategy\nsearch_space = {\n    "n_estimators": {"domain": range(10, 100)},\n    "max_depth": {"domain": range(1, 10)},\n    "learning_rate": {"domain": [0.001, 0.01, 0.1]},\n}\nsearch_strategy = "skopt"\n\n# Create a SparkEstimator object\nfrom pyspark.ml.classification import GBTClassifier\nestimator = GBTClassifier()\n\n# Pass the SparkEstimator object to FLAML\'s fit() method\nautoml = AutoML()\nautoml.fit(\n    X_train=data,\n    estimator=estimator,\n    task="classification",\n    search_space=search_space,\n    search_alg=search_strategy,\n    n_jobs=-1,\n)\n\n# Get the best model and its hyperparameters\nbest_model = automl.model\nbest_params = automl.best_config\n\n# Print the results\nprint(f"Best model: {best_model}")\nprint(f"Best hyperparameters: {best_params}")\n\n# Stop the SparkSession object\nspark.stop()\n```\n\nNote that the `n_jobs` parameter is set to `-1` to use all available cores on the Spark cluster. You can adjust this value to control the level of parallelism. Also, the `get_output_from_log()` function can be used to extract the results from the FLAML log file. \n\nTERMINATE\n\n--------------------------------------------------------------------------------\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>s});var a=t(7294);const o={},r=a.createContext(o);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);